# Задания на дом

## 2020-09-03

Дедлайн: 2020-09-10

### 0

- установить JDK, git
- создать **приватный** репозиторий 
  нужного формата
- задача 0 - программа выводит 
  `Hello world`

## 2020-09-08

Дедлайн: ~~2020-09-15~~ 2020-09-17

### 1

- ввести целые `x` и `y`
- вывести YES, если точка `(x,y)` находится в круге (граница принадлежит кругу)
  с радиусом 10, и NO иначе

### 2

- ввести целые `a` и `b`
- вывести периметр прямоугольника со сторонами `a` и `b`

## 2020-09-10

Дедлайн: 2020-09-17

### 3

- вводится `n`
- вводится `n` положительных целых чисел
- вывести сумму делителей этих чисел

```
3
1 4 5
14
```

В примере: `1+1+2+4+1+5`

### 4

- вводятся целые числа, ввод заканчивается, когда пользователь введёт `-1` (вводимых чисел не менее одного, пустых последовательностей чисел не будет)
- вывести минимальное число среди введённых

## 2020-09-15

Дедлайн: 2020-09-22

### 5

- вводится положительное целое число `n`
- вывести YES, если `n` представимо в виде суммы квадратов двух неотрицательных целых

```
25
YES
```

потому что `25 = 9 + 16`

```
10
YES
```

потому что `10 = 1 + 9`

```
7
NO
```

потому что `7 = 1 + 6 = 2 + 5 = 3 + 4`

### 6 

- вводится число `n`
- вводится `n` положительных целых чисел
- вывести `YES`, если все введённые числа ~~являются составными~~ не являются простыми

```
3
4 9 12
YES
```

```
4
4 3 6 9
NO
```

```
1
1
YES
```

потому что число 1 не является ни простым, ни составным

**UPD 2020-09-17.** Уточнено поведение на числе 1 (см. пример 3)

## 2020-09-17

Дедлайн: ~~2020-09-24~~ 2020-09-29.

### 7

- вводится число `n`
- вывести `YES`, если удвоенная сумма всех простых делителей числа больше `n`

```
14
YES
```

потому что `14 = 2 * 7 < 18 = 2*(2 + 7)`

```
18
NO
```

потому что `18 = 2*3^2; 2*(2+3) = 10 < 18`

### 8

- вводится число `n`
- вывести `YES`, если в разложении на простые делители `n` есть квадрат

```
30
NO
```

потому что `30 = 2*3*5`

```
24
YES
```

потому что `24 = 2^3 * 3`

### 9

- вводятся числа `n` и `k`
- проверить, что все простые делители `n` меньше `k`

```
98 10
YES
```

потому что `98 = 2 * 7^2` и `2 < 7 < 10`

```
77 10
NO
```

потому что `77 = 7 * 11` и `11 > 10`

```
13 13
NO
```

потому что 13 = 13 и 13 ≥ 13

## 2020-09-22

Дедлайн: 2020-09-29

### 10

Вводится последовательность целых чисел, ввод завершается `-1`.

Вывести сумму произведений троек соседних элементов (если меньше трёх элементов - выводится `0`).

```
1 2 3 -1
6
```

```
1 2 -1
0
```

```
1 2 3 4 -1
30
```

### 11

Вводится последовательность целых чисел, ввод завершается `-1`.

Вывести:
- символ `<`, если последовательность возрастает, 
- символ `>` - если убывает,
- символ `=` - если все элементы равны (включая случай, когда в последовательности меньше двух элементов),
- символ `!` - если последовательность не возрастает и не убывает (т.е. немонотонная). 

Сравнения нестрогие.

```
1 2 3 -1
<
```

```
3 2 1 -1
>
```

```
1 1 2 -1
<
```

```
2 2 1 -1
>
```

```
1 2 1 -1
!
```

```
1 1 1 -1
=
```

```
1 1 2 2 3 3 -1
<
```

```
1 1 2 2 1 1 -1
!
```

```
1 -1
=
```

```
-1
=
```

## 2020-09-24

Дедлайн: 2020-10-01

### 12

Вводятся целые числа, ввод завершается -1. Вывести сумму элементов между первым максимумом и последним минимумом (включая сами минимальный и максимальный элементы). Если максимум находится после минимума - ответ 0.

```
3 2 1 -1
6
```

```
3 2 5 2 1 -1
8
```

```
5 4 3 4 -1
12
```

```
5 4 3 4 1 -1
17
```

```
5 4 3 0 1 2 3 6 -1
0
```

```
5 3 5 3 1 3 1 -1
21
```

### 13

Вводятся целые числа, ввод завершается -1. Вывести второе по величине число (которое меньше максимального, но не меньше всех остальных). Если такого нет, вывести `NO`.

```
5 4 3 2 1 -1
4
```

```
5 5 4 3 2 -1
4
```

```
5 4 6 -1
5
```

```
5 -1
NO
```

```
5 5 -1
NO
```

```
-1
NO
```

## 2020-09-29

Дедлайн: 2020-10-06

### 14

Вводятся положительные целые числа, последовательность завершается -1.

Вывести максимальный элемент среди простых чисел в последовательности и сколько раз он встречается (или `NO`, если таких нет).

```
2 5 6 5 8 -1
5 2
```

```
1 6 8 -1
NO
```

### 15

Вводятся целые числа, последовательность завершается -1.

Вывести, сколько раз последовательность из неубывающей становится невозрастающей и наоборот.

```
1 2 3 2 1 -1
1
```

```
1 2 1 2 1 -1
3
```

```
1 2 2 1 -1
1
```

```
3 2 1 2 3 -1
1
```

```
2 2 2 2 -1
0
```

```
1 2 3 4 5 -1
0
```

```
5 4 3 2 1 -1
0
```

```
-1
0
```

```
1 -1
0
```

## 2020-10-06

Дедлайн: 2020-10-13

### 16

Вводится целое число N (от 2 до `100_000_000`).

Вывести пары чисел через пробел: простое число и степень этого простого в разложении N. Простые числа упорядочены по возрастанию.

Можете сохранить в массиве простые числа до `\sqrt N` (обратите внимание: хотя бы одно простое число в разложении будут не больше 10000, или N - простое) и проверить, делят ли они ваше число. При проверке будут вводиться и большие числа тоже (см., например, тест 04), поэтому наивная проверка всех чисел до N будет выдавать RE (решение должно отработать быстрее, чем за 5 секунд; решение с массивом работает быстрее, чем за секунду).

```
54
2 1 3 3
```
потому что `54 = 2 * 3^3`

```
77
7 1 11 1
```
потому что `77 = 7 * 11`

```
2
2 1
```
потому что `2 = 2`

```
99999989
99999989 1
```
потому что `99999989` - простое

UPD. Уточнена формулировка про простые числа в разложении числа

## 2020-10-08

Дедлайн: 2020-10-15

### 17

Вводится число N. Вводится N целых чисел (от 0 до 100) - цифры числа в Q-чной системе счисления.
Вводится число Q (от 2 до 101).

Вывести число из этих цифр в десятеричной системе счисления.

```
3
1 1 0
2
6
```
потому что `6_10 = 110_2`.

```
2
15 14
16
254
```
потому что `FE_16 = 254_10`.

### 18

Вводится число N
В каждой из следующих N строк вводится N целых чисел.

Проверить, что эта матрица NxN является магическим квадратом, вывести `YES` или `NO`.

```
3
2 7 6
9 5 1
4 3 8
YES
```
потому что суммы всех строк, столбцов, главной и побочной диагоналям равны: `2 + 7 + 6 = 9 + 5 + 1 = 4 + 3 + 8 = 2 + 9 + 4 = 7 + 5 + 3 = 6 + 1 + 8 = 2 + 5 + 8 + 4 + 5 + 6 = 15`

```
3
1 2 3
4 5 6
7 8 9
NO
```

## 2020-10-13

Дедлайн: 2020-10-20

## 19

Вводится `N` (`1 <= N < 100`). 

Вводится матрица `A`: `N` строк по `N` целых чисел в каждой.

Вводится матрица `B`: `N` строк по `N` целых чисел в каждой.

Вывести [произведение матриц `A` и `B`](https://ru.wikipedia.org/wiki/Умножение_матриц) в виде матрицы из `N` строк и `N` целых чисел в каждой

```
2
0 1
0 0
0 0
1 0
---
1 0
0 0
```

```
2
0 0
1 0
0 1
0 0
---
0 0
0 1
```

## 20

Вводятся `N` (`1 <= N < 1000`) и `M` (`1 <= M < 1000`). 

Вводится матрица: `N` строк по `M` целых чисел в каждой.

Назовём седловым элементом такой, что он минимальный в своей строке и максимальный в своём столбце.

Вывести индексы (строка и столбец через пробел, индексация с нуля) всех седловых элементов матрицы. Если их несколько - выводить в порядке слева направо, сверху вниз.

Примечание. Если проверять для каждого элемента, является ли он седловым, это будет долго. Лучше найти минимальный в строке и проверить, что он максимальный в столбце.

```
3 3
5 4 9
1 2 3
3 1 2
---
0 1
```

```
3 3
2 3 2
1 2 1
2 3 2
---
0 0
0 2
2 0
2 2
```

```
2 3
1 4 9
3 2 1
---
```

## 2020-10-15

Дедлайн: 2020-10-22

### 21

Написать функцию `int[] carry(int q, int[] a)`, которая выполняет переносы.

В массиве `a` хранятся цифры числа (возможно, превышающие основание `q` системы счисления), в индексе 0 - младшая цифра (например, `12` будет храниться как `a[0] = 2, a[1] = 1`; будем записывать это как `{2,1}`)

Вернуть новый массив, в котором число после выполнения переносов.

```
carry(10, {12,10,7,7,5,4})
---
{2,1,8,7,5,4}
```
потому что выполнили перенос из `12` и дальше из `10+1`.

```
carry(10, {42})
---
{2,4}
```

В последних элементах возвращенного массива могут быть нули. Гарантируется, что входные цифры не будут больше `q*q`. Гарантируется, что результат будет длиннее не более, чем на одну цифру. 

### 22

Написать функцию `int[] multiplyDigit(int q, int[] a, int k)`, которая умножает число `a` на цифру `k` (`0 <= k < q`) в системе счисления с основанием `q` и возвращает полученное число.

```
multiplyDigit(10, {6,5,4,3,2,1}, 3)
---
{8,6,3,0,7,3}
```
потому что `123456 * 3 = 370368`.

```
multiplyDigit(100, {1,2}, 0)
---
{0,0,0}
```

В последних элементах возвращенного массива могут быть нули.

Вы можете использовать функцию выполнения переносов, вызывая её как `P21.carry(...)`. Гарантируется, что она работает так, как указано в предыдущей задаче. Не гарантируется, что эта реализация - ваша.

## 2020-10-20

Дедлайн: 2020-10-27

### 23

Написать функцию `int[] add(int q, int[] a, int[] b)`, которая выполняет сложение двух чисел, записанных в виде массивов цифр `a` и `b` в системе счисления с основанием `q`.

В последних элементах возвращенного массива могут быть нули.

Можно использовать функции `P22.multiplyDigit` и `P21.carry`. Нельзя использовать встроенную в Java длинную арифметику.

```
add(10, [3,2,1], [1,2,3])
[4,4,4]
```

```
add(10, [9,9,9], [1])
[0,0,0,1]
```

```
add(10, [9,9,9], [9,9])
[8,9,0,1]
```

```
add(16, [15,8,4,3], [8,4,3])
[7,13,7,3]
```

### 24

Написать функцию `int[] multiply(int q, int[] a, int[] b)`, которая выполняет умножение двух чисел, записанных в виде массивов цифр `a` и `b` в системе счисления с основанием `q`.

В последних элементах возвращенного массива могут быть нули.

Можно использовать функции `P23.add`, `P22.multiplyDigit` и `P21.carry`. Нельзя использовать встроенную в Java длинную арифметику.

```
multiply(10, [1,2,3], [1])
[1,2,3]
```

```
multiply(16, [15,14], [13,12])
[3,6,15,11]
```

```
multiply(10, [9,9,9,9], [0])
[0]
```

```
multiply(8, [7,7,7,7], [7,7,7,7])
[1,0,0,0,6,7,7,7]
```

## 2020-10-27

Дедлайн: 2020-11-03

Для следующих заданий будут подготовлены вспомогательные файлы `Source.java` и `Sink.java`. Менять в них ничего не нужно. Также будет подготовлен пример их использования в `main`. Как и раньше, нужно написать только указанную функцию в классе `PNNN.java`; функцию `main` в том же классе вы можете использовать для тестирования вашего решения.

### 25

В этой задаче вам нужно вызывать `src.nextInt()` для получения следующего входного числа (аргументов у `src.nextInt()` нет, а возвращается `int` - целое число). Последнее число, которое будет возвращено - `-1`, после этого дальнейшие вызовы `src.nextInt()` будут возвращать ошибку. Можно считать, что это аналог `Scanner`, используемый для ввода чисел; в примере числа вводятся с клавиатуры.

Количество входных чисел, возвращаемых `src.nextInt()`, неизвестно; последнее число - `-1`. Все входные числа не меньше 0 и не больше 1000.

Написать функцию `void count(Source src, int[] cnt)`, которая получает все числа, вызывая `src.nextInt()`, и возвращает в массиве `cnt`, сколько раз встретилось соответствующее число. Массив `cnt` содержит не меньше 1000 элементов, все элементы инициализированы нулем.

Если `src.nextInt()` возвращает, соответственно, числа `1 2 3 -1`, то в результате массив `cnt` должен быть изменён так, что `cnt[1] == 1`, `cnt[2] == 1`, `cnt[3] == 1`, а остальные элементы массива `cnt` равны 0.

```
1 1 1 -1
---
cnt[1] == 3
```

### 26

В этой задаче вам нужно вызывать `sink.yield(x)`, где `x` - какое-то целочисленное выражение. Вызовы должны быть в указанном в задаче порядке и количестве. Можно считать, что это аналог `System.out.println`, который используется для вывода целых чисел; в примере числа выводятся на экран.

Написать функцию `void uncount(int[] cnt, Sink sink)`, которая получает массив `cnt` целых чисел, где записано количество чисел. Вызвать `sink.yield` с этими числами в порядке возрастания указанное количество раз.

Если `cnt` содержит массив `{1,1,1}`, то в результате выполнения функции должны произойти вызовы
```
sink.yield(0);
sink.yield(1);
sink.yield(2);
```
Каждое число от 0 до 2 выступает аргументом один раз.

```
{3,0,1}
---
sink.yield(0);
sink.yield(0);
sink.yield(0);
sink.yield(2);
```
Три раза функция вызвана с 0, нуль раз - с 1 и один раз - с 2 в качестве аргумента.

```
{4,1,3,4}
---
sink.yield(0);
sink.yield(0);
sink.yield(0);
sink.yield(0);
sink.yield(1);
sink.yield(2);
sink.yield(2);
sink.yield(2);
sink.yield(3);
sink.yield(3);
sink.yield(3);
sink.yield(3);
```
Четыре раза - аргумент 0, один раз - аргумент 1, три раза - аргумент 2 и четыре раза - аргумент 3.

## 2020-10-29

Дедлайн: 2020-11-05

### 27

Написать функцию `int find(int[] needle, Source hive)`, которая ищет в последовательности чисел, возвращаемых `hive.nextInt()` (до `-1`), первый участок, равный числам из `needle`, и возвращает индекс первого числа из этого участка (или `-1`, если такого нет).

В `hive` чисел больше, чем в `needle`.

```
needle={1,2,3} hive={1,2,1,1,2,3}
---
3
```

```
needle={1,2} hive={1,1,1,1,3,2}
---
-1
```
искомой подпоследовательности нет

```
needle={1,2,3} hive={1,2,3,1,2,3}
---
0
```
возвращается начало первого участка, а не второго

## 2020-11-05

Дедлайн: 2020-11-12

### 28

Написать класс `Counter`, у которого есть 
* конструктор `Counter(int start)` - создаётся счётчик, с указанным начальным показанием `start`
* метод `void increase()`, который увеличивает показания на 1
* метод `void decrease(int count)`, который уменьшает показания на `count`
* метод `int getCurrent()`, который возвращает текущие показания.

Счётчиков может быть много, их показания не зависят друг от друга.

(в папке `28` должен быть файл `Counter.java` с реализацией)

```
Counter c = new Counter(5);
c.getCurrent(); // 5
c.increase();
c.getCurrent(); // 6
c.decrease(3);
c.getCurrent(); // 3
```

## 2020-11-10

Дедлайн: 2020-11-17

### 29

Написать `LimitedCounter`, который наследует `Counter`, у которого есть:
- конструктор `LimitedCounter(int limit)`:
  задаёт ограничение `limit` и начальное значение 0
- метод `int getLimit()`, который возвращает  текущий лимит
- метод `void setLimit(int limit)`, который устанавливает лимит
- метод `void increase()`, который увеличивает на единицу, если текущее значение меньше лимита

```
Counter c = new LimitedCounter(2); // 0
c.increase(); // 1
c.increase(); // 2
c.increase(); // 2
```

## 2020-11-19

Дедлайн: 2020-11-26

### 30

В интерфейсе `Pressable` есть два метода:
- `String press(int key)` - возвращает строку, что происходит при нажатии на кнопку с номером `key` (от 0)
- `int getKeyCount()` - возвращает количество кнопок

Реализуйте класс `Pressing` с методом:
- `void pressAllButtons(Pressable pressable)`

Метод должен нажать на все кнопки переданного объекта (с возвращаемыми строками ничего делать не нужно).

В папке `30` достаточно иметь только файл `Pressing.java`

## 2020-11-24

Дедлайн: 2020-12-01

Снова нужно писать `PN.java` (`P31.java`, `P32.java`).

### 31

Написать статический метод `int wow(String s)`, который возвращает, сколько раз в строке `s` встречается подстрока `wow` (с учётом регистра).

В решении для работы со строкой использовать только методы `length()` и `charAt(...)`.

```
wow("wow! Hello wowrld!")
---
2
```

```
wow("woooow!")
---
0
```

```
wow("WOW")
---
0
```

```
wow("wowowow")
---
3
```

```
wow("")
---
0
```

### 32

Написать класс `P32`:
- конструктор `P32(String s)` подсчитывает, сколько раз встречается каждая строчная буква английского алфавита ('a' - 'z');
- метод `int getCount(char c)` должен вернуть, сколько раз был подсчитан символ `c` в конструкторе (если `c` - не строчная буква английского алфавита, возвращается 0)

Строки могут быть очень длинные, нужно считать статистику в конструкторе, а в `getCount(c)` только возвращать результат подсчёта

```
P32 p = new P32("abbcccCCляляля");
p.getCount('a') == 1
p.getCount('b') == 2
p.getCount('c') == 3
p.getCount('z') == 0
p.getCount('C') == 0
p.getCount('я') == 0
```

## 2020-11-26

Дедлайн: 2020-12-03

### 33

Написать статический метод `int countCapitals(String s)`, который возвращает, сколько слов в строке `s` начинаются с заглавной буквы.

Заглавной буквой считается символ (Character) типа `UPPERCASE_LETTER` или типа `TITLECASE_LETTER`. Словом считается последовательность букв или цифр, разделённых одним или несколькими пробельными символами (whitespace), знаками (symbol) или знаками пунктуации (punctuation).

```
P33.countCapitals("Hello,My dear friends!Here—Words beginning with Ćapital ŁeTtErS") == 6
```

### 34

Написать статический метод `void replace(String s, StringBuilder b)`, который добавляет в `b` все символы из строки `s`, заменяя последовательность `Trump` на `Biden` (в такой капитализации) и `вики` на `энцикло` (сохраняя капитализацию первой буквы).

```
StringBuilder sb = new StringBuilder();
P34.replace("Wikipedia says that Trump is the President. Викинги грабили википедию и получился мем", sb);
// sb.toString() == "Wikipedia says that Biden is the President. Энциклонги грабили энциклопедию и получился мем"
```

Использовать только методы классов String, StringBuilder.

## 2020-12-01

Дедлайн: 2020-12-08

Написать регулярное выражение, которое проверяет целиком строку (без дополнительной обработки после проверки)

### 35

Написать статический метод `boolean isPeriodic(String s)`, который будет проверять, является ли строка записью вещественного числа с периодом

```
P35.isPeriodic("1") == true
P35.isPeriodic("1.213") == true
P35.isPeriodic("1.23(16)") == true
P35.isPeriodic(".(6)") == true
P35.isPeriodic("0.6(6)") == true
P35.isPeriodic("1.23(15)1") == false
P35.isPeriodic("1.23(15)1(56)") == false
P35.isPeriodic("hello(123)") == false
P35.isPeriodic(" 1.2(3)") == false
P35.isPeriodic("1(2)") == false
```

### 36

Написать статический метод `boolean isTime(String s)`, который будет проверять, является ли строка записью времени в формате час-минута-секунда.

Час может быть как одной цифрой, так и двумя, минуты и секунды - две цифры. Секунды могут отсутствовать

```
P36.isTime("15:23:18") == true
P36.isTime("1:23:45") == true
P36.isTime("1:23") == true
P36.isTime("1") == false
P36.isTime("24:00:00") == false
P36.isTime("0:60:00") == false
P36.isTime("01:23:45") == true
```

## 2020-12-03

Дедлайн: 2020-12-10

### 37

На вход подается строка, каждая строка представляет собой двоичный код. 

Правильным кодом называется строка, которая состоит либо только из нулей, либо
только из единиц, либо нули и единицы в ней чередуются.

Написать статическую функцию `boolean isCorrectCode(String s)`, которая возвращает,
правильный ли код (использовать matches)

```
P37.isCorrectCode("010101") == true
P37.isCorrectCode("0110") == false
P37.isCorrectCode("11") == true
P37.isCorrectCode("001") == false
P37.isCorrectCode("00") == true
P37.isCorrectCode("11101") == false
P37.isCorrectCode("101") == true
P37.isCorrectCode("") == true
P37.isCorrectCode("00110011") == false
```

### 38

На вход подаётся строка, в которой есть слова "google" (с разным количеством букв "o": "gooogle", "gooooogle", количество букв "o" не меньше 2).

Вам нужно написать статическую функцию `int countGoogleProduct(String s)`, которая возвращает произведение количеств букв "o" во всех словах "google", "gooogle", ...

Гарантируется, что ответ будет не больше `2*10^9`.

```
P38.countGoogleProduct("google gooogle") == 6 == 2*3
P38.countGoogleProduct("google gogle gooogle gooogle") == 18 == 2*3*3
P38.countGoogleProduct("microsoft gogle") == 1
P38.countGoogleProduct("microsoft amazon facebooooook") == 1
P38.countGoogleProduct("googleing") == 1
P38.countGoogleProduct("googlee") == 1
P38.countGoogleProduct("  google   google  ") == 4 == 2*2
P38.countGoogleProduct("googlegoogle") == 1
```

## 2020-12-08

Дедлайн: 2020-12-15

### 39

В качестве входа подаётся строка, в которой через запятую написаны фамилия, имя, отчество человека, год и событие. Сами эти поля не будут содержать запятых.

Написать статическую функцию `String convert(String s)`, которая преобразует входную строку в следующий вид: `"И.О. Фамилия" совершил "событие" в "год" году`, где `"И.О. Фамилия"`, `"событие"` и `"год"` -- соответствующие поля входной строки (изменять падеж и род не нужно).

```
P39.convert("Гагарин,Юрий,Алексеевич,1961,полёт в космос") == "Ю.А. Гагарин совершил полёт в космос в 1961 году"
P39.convert("Королёв,Сергей,Павлович,1957,запуск спутника") == "С.П. Королёв совершил запуск спутника в 1957 году"
P39.convert("Терешкова,Валентина,Владимировна,2020,подготовка конституции") == "В.В. Терешкова совершил подготовка конституции в 2020 году"
```

Нужно использовать соответствующие методы классов `Pattern` и `Matcher` (которые содержат что-то в духе replace в названии) и ссылки на захваченные группы в регулярных выражениях.

## 2020-12-10

Дедлайн: 2020-12-17

### 40

Запрограммируйте управление шлагбаумом на въезде на парковку. 

Шлагбаум может находиться в трёх положениях: полностью опущенном (закрытом), наполовину поднятом и полностью поднятом (открытом). Также есть два сенсора: один, который возвращает, находится ли машина перед въездом, и второй - который возвращает, проехала ли машина въезд. Управляющая программа (контроллер) может вернуть одну из трёх команд: поднимать шлагбаум, ничего не делать или опускать шлагбаум.

Если перед въездом находится машина, шлагбаум нужно начать поднимать. Если машина проехала въезд, шлагбаум нужно начать опускать. Шлагбаум поднимается и опускается, проходя через каждое из своих положений в течение одной единицы времени. Машина может проезжать въезд в течение нескольких единиц времени.
Сенсор перед въездом срабатывает, когда машина подъехала к шлагбауму и продолжает срабатывать, пока машина проезжает шлагбаум. Сенсор после въезда срабатывает, когда машина полностью проехала шлагбаум.

Для моделирования этого вам нужно написать класс `P40`:
- конструктор по умолчанию создаёт контроллер, считающий, что шлагбаум закрыт;
- конструктор `P40(State gate)` создаёт контроллер, считающий, что шлагбаум в указанном состоянии:
  + закрытый `State.CLOSED`,
  + наполовину открытый `State.HALF_OPEN`,
  + открытый `State.OPEN`;
- метод `State getGate()`, который возвращает текущее состояние шлагбаума по мнению контроллера;
- метод `Action control(bool carBeforeGate, bool carAfterGate)`, который принимает значения сенсоров, соответственно, перед въездом и после него, обновляет представление о состоянии шлагбаума в контроллере и возвращает команду:
  + поднимать шлагбаум `Action.UP`,
  + ничего не делать `Action.NOTHING`,
  + опускать шлагбаум `Action.DOWN`.

Метод `control` будет вызываться один раз в единицу времени. Например, чтобы полностью поднять шлагбаум из закрытого состояния, функция `control` должна дважды подряд вернуть `Action.UP`.
